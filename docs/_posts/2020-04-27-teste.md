---
title: Introdu√ß√£o √† Julia - Parte 05 - Tipos e Escopos de Vari√°veis
tags: [Introdu√ß√£o, Julia]
style: fill
color: secondary
description: Tipos de vari√°veis, declara√ß√£o do tipo da vari√°vel, struct e escopo de vari√°veis.
---

# Comandos B√°sicos
## T√≥picos:
1. Coment√°rio;
2. Opera√ß√µes B√°sicas;
3. Vari√°veis;
4. Tipos de Vari√°veis;
5. String;
6. Operadores L√≥gicos;
7. Compara√ß√£o;
8. Imprimir;
9. Entrada e Sa√≠da;
10. Consulta de Comandos.

### Coment√°rio


```julia
# Para coment√°rios com uma linha.

#=

Para
coment√°rios
com 
m√∫ltiplas 
linhas.

=#
```

### Opera√ß√µes B√°sicas


```julia
3 + 7;             # soma
10 - 3;            # diferen√ßa
20 * 5;            # produto
10 / 6;            # quociente
10 % 6;            # resto
div(10, 6);        # parte inteira do quociente
10 // 6;           # fra√ß√£o
numerator(2//3);   # numerador
denominator(2//3); # denominador
10 ^ 2;            # pot√™ncia
sqrt(2);           # raiz quadrada
abs(-2);           # valor absoluto
exp(1);            # exponencial
log(b,x);          # logaritmo de x na base b
```


```julia
y += 1;      # √© equivalente a y = y + 1
x *= 3;      # √© equivalente a x = x * 3
```

#### Opera√ß√£o com 0 e infinito


```julia
1/0
```




    Inf




```julia
1/Inf
```




    0.0




```julia
-5/0
```




    -Inf




```julia
0.000001/0
```




    Inf




```julia
500 + Inf
```




    Inf




```julia
500 - Inf
```




    -Inf




```julia
Inf + Inf
```




    Inf




```julia
Inf - Inf
```




    NaN




```julia
Inf / Inf
```




    NaN




```julia
0 * Inf
```




    NaN




```julia
0/0
```




    NaN



## Vari√°veis


```julia
numero_inteiro = 10;
numero_real = 3.14159;
numero_complexo = 1 + 2im;
string = "Hello World!";
caractere = 'a';
valor_logico = true;
infinito = Inf;
nada1 = nothing; # retorna: nada
nada2 = NaN;
```

## Tipos de Vari√°veis

### Hier√°rquia dos n√∫meros:

![](https://upload.wikimedia.org/wikipedia/commons/4/40/Type-hierarchy-for-julia-numbers.png)

Fonte: https://upload.wikimedia.org

### Inteiros:
![](img/Integer.png)

Fonte: https://docs.julialang.org/en/v1/manual/integers-and-floating-point-numbers/

### Reais:
![](img/Float.png)

Fonte: https://docs.julialang.org/en/v1/manual/integers-and-floating-point-numbers/


```julia
var = true
typeof(var) # retorna o tipo da vari√°vel
```




    Bool




```julia
quarenta_e_dois = (42, 42.0, 4.20e1, 4.20f1, 84//2, 0x2a)

for x in quarenta_e_dois
    println("$x \t √© um $(typeof(x))")
end
```

    42 	 √© um Int64
    42.0 	 √© um Float64
    42.0 	 √© um Float64
    42.0 	 √© um Float32
    42//1 	 √© um Rational{Int64}
    42 	 √© um UInt8
    

### Vari√°veis Especiais
https://docs.julialang.org/en/v1/manual/unicode-input/
#### Exemplo 1: Emoji
Digite `\:smi`, aperte `Tab`, selecione `smile_cat:`, aperte `Enter`, aperte `Tab` novamente, selecione a imagem e, por fim, aperte `Enter`.<br>
Resultado:
üò∫


```julia
üò∫ = "Smiley Cat!"
typeof(üò∫)
```




    String



#### Exemplo 2: Alfabeto Grego
Digite `\epsilon` e aperte `Tab`.<br>
Resultado: œµ


```julia
œÄ   # \pi
œï   # \phi
Œº   # \mu
```

#### Exemplo 3: Opera√ß√µes
Digite `\sqrt`e aperte `Tab`.<br>
Resultado: ‚àö


```julia
‚àö4
```




    2.0



### String


```julia
str = "Hello, world!\n"

str[begin]      # primeira posi√ß√£o de str
str[1]          # posi√ß√£o 1 de str
str[6]          # posi√ß√£o 6 de str
str[6:6]        # posi√ß√£o 6
str[end]        # √∫ltima posi√ß√£o de str
str[end-1]      # antepen√∫ltima posi√ß√£o de str
str[4:9]        # da posi√ß√£o 4 at√© a 9 de str

firstindex(str) # √≠ndice da primeira posi√ß√£o de str
lastindex(str)  # √≠ndice da √∫ltima posi√ß√£o de str

length(str,4,6) # quantidade de caracteres entre 4 e 6 inclusive
```


```julia
findfirst(isequal('o'), "Hello World")  # encontrar √≠ndice de um caractere a partir da primeira posi√ß√£o
```




    5




```julia
findlast(isequal('o'), "Hello World")   # encontrar √≠ndice de um caractere a partir da √∫ltima posi√ß√£o
```




    8




```julia
findnext(isequal('o'), "Hello World",1) # encontrar √≠ndice de um caractere ap√≥s a posi√ß√£o 1
```




    5




```julia
findnext(isequal('o'), "Hello World",5) # encontrar √≠ndice de um caractere ap√≥s a posi√ß√£o 5
```




    5




```julia
findprev(isequal('o'), "Hello World",1) # encontrar √≠ndice de um caractere antes da posi√ß√£o 1
```


```julia
findprev(isequal('o'), "Hello World",5) # encontrar √≠ndice de um caractere antes da posi√ß√£o 5
```




    5



## Operadores L√≥gicos


```julia
false && true    # 'e'
false || true    # 'ou'
!true            # nega√ß√£o
true ‚äª true      # 'ou' exclusivo
```

## Compara√ß√£o


```julia
1 == 1.0     # igual
1 != 0       # diferente
3 < œÄ        # menor
3 <= œÄ       # menor ou igual
4 > 3        # maior
4 >= 4       # maior ou igual
```


```julia
1 < 2 < 3
```




    true




```julia
1 < 3 > 2
```




    true




```julia
1 < 2 < 3 >= 3 > 2.5 == 2.5000 != 7 <= 8
```




    true




```julia
1000 == 1.0e3
```




    true




```julia
0.001 == 1.0e-3
```




    true




```julia
10_500 == 10500
```




    true




```julia
0.000_000_005 == 0.000000005
```




    true




```julia
# Os caracteres est√£o ordenado de acordo com o ASCII (https://commons.wikimedia.org/wiki/File:ASCII-Table.svg)

'A' < 'a'
```




    true




```julia
'A' <= 'a' <= 'Z'
```




    false




```julia
'x' - 'a' # subtra√ß√£o da posi√ß√£o de 'x' e da posi√ß√£o de 'a', segundo a ordem ASCII
```




    23




```julia
'A' + 1   # retorna o pr√≥ximo caractere
```




    'B': ASCII/Unicode U+0042 (category Lu: Letter, uppercase)




```julia
"abracadabra" < "xylophone"
```




    true



## Imprimir


```julia
println("Imprime e pula uma linha.")
print("Imprime e n√£o pula ")
print("linha.")
```

    Imprime e pula uma linha.
    Imprime e n√£o pula linha.


```julia
println("""Com tr√™s aspas √© poss√≠vel escrever 
            palavras entre "aspas" 
            e
            escreve do jeito que est√° 
            sendo apresentado.""")
```

    Com tr√™s aspas √© poss√≠vel escrever 
    palavras entre "aspas" 
    e
    escreve do jeito que est√° 
    sendo apresentado.
    


```julia
"\n" # pula linha
"\t" # tab
```


```julia
# imprimir vari√°vel

linguagem = "Julia"
versao = 1.4

println(" Linguagem: \t $linguagem \n Vers√£o: $versao")

#ou

println(" Linguagem: ", linguagem, "\n Vers√£o: ", versao)
```

     Linguagem: 	 Julia 
     Vers√£o: 1.4
     Linguagem: Julia
     Vers√£o: 1.4
    


```julia
numero1 = 10
numero2 = 20
println("$numero1 + $numero2 = $(numero1 + numero2)")
```

    10 + 20 = 30
    


```julia
# Concatena√ß√£o:

s1 = "Hello "
s2 = "World!"

string(s1, s2)
```




    "Hello World!"




```julia
s1*s2
```




    "Hello World!"



## Entrada e Sa√≠da


```julia
entrada_string = readline() # retorna como string
```

    stdin> KL
    




    "KL"




```julia
typeof(entrada_string)
```




    String




```julia
entrada_int = parse(Int, readline()) # converte o que foi digitado para inteiro
```

    stdin> 05
    




    5




```julia
typeof(entrada_int)
```




    Int64




```julia
entrada_float = parse(Float64, readline()) # converte o que foi digitado para float
```

    stdin> 0.5
    




    0.5




```julia
typeof(entrada_float)
```




    Float64



## Consulta de Comandos

`?` seguido de um comando retorna a documenta√ß√£o desse comando em ingl√™s.


```julia
?typeof
```

    search: [0m[1mt[22m[0m[1my[22m[0m[1mp[22m[0m[1me[22m[0m[1mo[22m[0m[1mf[22m [0m[1mt[22m[0m[1my[22m[0m[1mp[22m[0m[1me[22mj[0m[1mo[22min [0m[1mT[22m[0m[1my[22m[0m[1mp[22m[0m[1me[22mErr[0m[1mo[22mr
    
    




```
typeof(x)
```

Get the concrete type of `x`.

# Examples

```jldoctest
julia> a = 1//2;

julia> typeof(a)
Rational{Int64}

julia> M = [1 2; 3.5 4];

julia> typeof(M)
Array{Float64,2}
```





```julia
?parse
```

    search: [0m[1mp[22m[0m[1ma[22m[0m[1mr[22m[0m[1ms[22m[0m[1me[22m try[0m[1mp[22m[0m[1ma[22m[0m[1mr[22m[0m[1ms[22m[0m[1me[22m [0m[1mp[22m[0m[1ma[22m[0m[1mr[22mtial[0m[1ms[22mortp[0m[1me[22mrm [0m[1mp[22m[0m[1ma[22m[0m[1mr[22mtial[0m[1ms[22mortp[0m[1me[22mrm! [0m[1mp[22m[0m[1ma[22mi[0m[1mr[22m[0m[1ms[22m ski[0m[1mp[22mch[0m[1ma[22m[0m[1mr[22m[0m[1ms[22m
    
    




```
parse(type, str; base)
```

Parse a string as a number. For `Integer` types, a base can be specified (the default is 10). For floating-point types, the string is parsed as a decimal floating-point number.  `Complex` types are parsed from decimal strings of the form `"R¬±Iim"` as a `Complex(R,I)` of the requested type; `"i"` or `"j"` can also be used instead of `"im"`, and `"R"` or `"Iim"` are also permitted. If the string does not contain a valid number, an error is raised.

!!! compat "Julia 1.1"
    `parse(Bool, str)` requires at least Julia 1.1.


# Examples

```jldoctest
julia> parse(Int, "1234")
1234

julia> parse(Int, "1234", base = 5)
194

julia> parse(Int, "afc", base = 16)
2812

julia> parse(Float64, "1.2e-3")
0.0012

julia> parse(Complex{Float64}, "3.2e-1 + 4.5im")
0.32 + 4.5im
```



